% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }



\title{emus Documentation}
\date{April 07, 2016}
\release{}
\author{Author}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Quickstart}
\label{quickstart::doc}\label{quickstart:quickstart}\label{quickstart:documentation-for-the-emus}
This guide covers perform typical tasks with the EMUS package.  The required data files, as well as a (slightly modified) script containing all of the python commands used below, can be found in the examples directory of the package in the AlaDipeptide\_1D directory. The guide will make use of the numpy and matplotlib packages.


\section{Loading from WHAM-like Formats}
\label{quickstart:loading-from-wham-like-formats}
The usutils module provides a method that loads data in the format used by WHAM.  It outputs the trajectory in collective variable space as well as the \(\psi_ij(x_n)\) values.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{usutils} \PYG{k+kn}{as} \PYG{n+nn}{uu}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Define Simulation Parameters}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{310}                             \PYG{c}{\PYGZsh{} Temperature in Kelvin}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{meta\PYGZus{}file} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{wham\PYGZus{}meta.txt}\PYG{l+s}{\PYGZsq{}}         \PYG{c}{\PYGZsh{} Path to Meta File}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dim} \PYG{o}{=} \PYG{l+m+mi}{1}                             \PYG{c}{\PYGZsh{} 1 Dimensional CV space.}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{period} \PYG{o}{=} \PYG{l+m+mi}{360}                        \PYG{c}{\PYGZsh{} Dihedral Angles periodicity}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c}{\PYGZsh{} Load data}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{psis}\PYG{p}{,} \PYG{n}{cv\PYGZus{}trajs} \PYG{o}{=} \PYG{n}{uu}\PYG{o}{.}\PYG{n}{data\PYGZus{}from\PYGZus{}WHAMmeta}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{wham\PYGZus{}meta.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{dim}\PYG{p}{,}\PYG{n}{T}\PYG{o}{=}\PYG{n}{T}\PYG{p}{,}\PYG{n}{period}\PYG{o}{=}\PYG{n}{period}\PYG{p}{)}
\end{Verbatim}


\section{Calculating the PMF}
\label{quickstart:calculating-the-pmf}
We can now build the EMUS object (this automatically calculates the relative normalization constants according to the first EMUS iteration).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{emus} \PYG{k+kn}{import} \PYG{n}{emus}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{EM} \PYG{o}{=} \PYG{n}{emus}\PYG{p}{(}\PYG{n}{psis}\PYG{p}{,}\PYG{n}{cv\PYGZus{}trajs}\PYG{p}{)}
\end{Verbatim}

To calculate the potential of mean force, we provide the number of histogram bins and the range of the collective variable, and call the appropriate method of the EMUS object.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{domain} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{180.0}\PYG{p}{,}\PYG{l+m+mf}{180.}\PYG{p}{)}\PYG{p}{)}            \PYG{c}{\PYGZsh{} Range of dihedral angle values}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pmf} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}pmf}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,}\PYG{n}{nbins}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}   \PYG{c}{\PYGZsh{} Calculate the pmf}
\end{Verbatim}

We can now plot the potential of mean force using pyplot or other tools.  Note that this returns the unitless free energy by default: the user can either multiply the pmf by \(k_B T\) in postprocessing, or specify \(k_B T\) as a parameter for calc\_pmf.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{centers} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{177}\PYG{p}{,}\PYG{l+m+mi}{177}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{)}  \PYG{c}{\PYGZsh{} Center of the histogram bins}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{centers}\PYG{p}{,}\PYG{n}{pmf}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Estimating Window Partition Functions}
\label{quickstart:estimating-window-partition-functions}
Upon creation, the EMUS object already estimates the relative partition function (denoted \(z\)) of each window using the EMUS estimator.  These are contained in the object, and can be accessed directly.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{print} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{z}
\end{Verbatim}

The EMUS object also has the ability to calculate the relative partition functions from the MBAR estimator.  This requires solving a self-consistent iteration.  The nMBAR parameter specifies the maximum number of iterations.  Note that truncating early still provides a consistent estimator, and introduces no systematic bias.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z\PYGZus{}MBAR\PYGZus{}1}\PYG{p}{,} \PYG{n}{F\PYGZus{}MBAR\PYGZus{}1} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}zs}\PYG{p}{(}\PYG{n}{nMBAR}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z\PYGZus{}MBAR\PYGZus{}2}\PYG{p}{,} \PYG{n}{F\PYGZus{}MBAR\PYGZus{}2} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}zs}\PYG{p}{(}\PYG{n}{nMBAR}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z\PYGZus{}MBAR\PYGZus{}5}\PYG{p}{,} \PYG{n}{F\PYGZus{}MBAR\PYGZus{}5} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}zs}\PYG{p}{(}\PYG{n}{nMBAR}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{z\PYGZus{}MBAR\PYGZus{}1k}\PYG{p}{,} \PYG{n}{F\PYGZus{}MBAR\PYGZus{}1k} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}zs}\PYG{p}{(}\PYG{n}{nMBAR}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}
\end{Verbatim}

We can plot the unitless window free energies for each max iteration number to see how our estimates converge.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{EM}\PYG{o}{.}\PYG{n}{z}\PYG{p}{)}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration 0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{z\PYGZus{}MBAR\PYGZus{}1}\PYG{p}{)}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration 1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{z\PYGZus{}MBAR\PYGZus{}2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration 2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{z\PYGZus{}MBAR\PYGZus{}5}\PYG{p}{)}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration 5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{log}\PYG{p}{(}\PYG{n}{z\PYGZus{}MBAR\PYGZus{}1k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration 1k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The pmf can be constructed using these values for the relative partition functions. \footnote{
Technically speaking, this is mixing estimators: the \(z\)`s are being estimated using the MBAR estimator, whereas the pmf is estimated using the MBAR \(z\)`s, but with the EMUS estimator (MBAR iteration 0).  However, in practice the majority of the error comes from estimating the normalization constant.  Consequently, the estimator used for estimating the pmf affects the results much less.
}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{MBARpmf} \PYG{o}{=} \PYG{n}{EM}\PYG{o}{.}\PYG{n}{calc\PYGZus{}pmf}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,}\PYG{n}{nbins}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{n}{z}\PYG{o}{=}\PYG{n}{z\PYGZus{}MBAR\PYGZus{}1k}\PYG{p}{)}
\end{Verbatim}


\chapter{Data Structures}
\label{datastructures:data-structures}\label{datastructures::doc}
This section discusses commonly used variables and naming conventions used throughout the EMUS package. These are not strict standards: the EMUS package attempts to duck-type as much as possible to interpret user input.  The documentation below is intended to indicate approximately what form inputs can take, and to aid comprehension of the source code.


\section{Parameters for Harmonic Umbrellas}
\label{datastructures:parameters-for-harmonic-umbrellas}
These variables contain parameters of the umbrella sampling system.
\begin{quote}\begin{description}
\item[{centers}] \leavevmode
A two-dimensional array-like containing the center of each harmonic window in collective variable space.  The first index corresponds to the windox index, and the second to the collective variable index: \code{centers{[}2{]}} gives the coordinate of the third umbrella.

\item[{fks}] \leavevmode
A two-dimensional array-like containing the force constant for each umbrella.  The syntax and format is the same as for centers.

\item[{kTs}] \leavevmode
A one-dimensional array-like with the Boltzmann factor for each window, where the index corresponds to the window index. Alternatively, if the Boltzmann factor is the same for all windowse, EMUS will accept a scalar value for \(k_B T\).

\item[{period}] \leavevmode
Encodes the period of the

\item[{neighbors}] \leavevmode
amet

\end{description}\end{quote}


\section{Data from Sampling}
\label{datastructures:data-from-sampling}\begin{quote}\begin{description}
\item[{cv\_trajectories}] \leavevmode
consectetuer

\item[{psis}] \leavevmode
adipiscing

\item[{fndata}] \leavevmode
elit

\item[{iats}] \leavevmode
Aenean

\end{description}\end{quote}


\section{Other Conventions}
\label{datastructures:other-conventions}
...


\chapter{EMUS Modules}
\label{modules/index::doc}\label{modules/index:emus-modules}
Contents:


\section{autocorrelation module}
\label{modules/autocorrelation::doc}\label{modules/autocorrelation:autocorrelation-module}\label{modules/autocorrelation:module-autocorrelation}\index{autocorrelation (module)}
Tools for analyzing the autocorrelation of a time series
\index{autocorrfxn() (in module autocorrelation)}

\begin{fulllineitems}
\phantomsection\label{modules/autocorrelation:autocorrelation.autocorrfxn}\pysiglinewithargsret{\code{autocorrelation.}\bfcode{autocorrfxn}}{\emph{timeseries}, \emph{lagmax}}{}
\end{fulllineitems}

\index{icce() (in module autocorrelation)}

\begin{fulllineitems}
\phantomsection\label{modules/autocorrelation:autocorrelation.icce}\pysiglinewithargsret{\code{autocorrelation.}\bfcode{icce}}{\emph{timeseries}, \emph{lagmax=None}}{}
Initial convex correlation time estimator

\end{fulllineitems}

\index{ipce() (in module autocorrelation)}

\begin{fulllineitems}
\phantomsection\label{modules/autocorrelation:autocorrelation.ipce}\pysiglinewithargsret{\code{autocorrelation.}\bfcode{ipce}}{\emph{timeseries}, \emph{lagmax=None}}{}
Initial positive correlation time estimator

\end{fulllineitems}



\section{avar module}
\label{modules/avar:avar-module}\label{modules/avar::doc}\label{modules/avar:module-avar}\index{avar (module)}
Library with routines associated with the asymptotic variance of the
first EMUS iteration.  These estimates rely on estimates of
\index{avar\_obs() (in module avar)}

\begin{fulllineitems}
\phantomsection\label{modules/avar:avar.avar_obs}\pysiglinewithargsret{\code{avar.}\bfcode{avar\_obs}}{\emph{psis}, \emph{z}, \emph{F}, \emph{f1data}, \emph{f2data=None}, \emph{neighbors=None}, \emph{iat\_method='ipce'}}{}
Estimates the asymptotic variance in the ratio of two observables.
If f2data is not given, it just calculates the asymptotic variance
associated with the average of f1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus.py for a detailed explanation.
\end{quote}

\textbf{z} : 1D array
\begin{quote}

Array containing the normalization constants
\end{quote}

\textbf{F} : 2D array
\begin{quote}

Overlap matrix for the first EMUS iteration.
\end{quote}

\textbf{f1data} : 2D data structure
\begin{quote}

Trajectory of observable in the numerator.  First dimension corresponds to the umbrella index and the second to the point in the trajectory.
\end{quote}

\textbf{f2data} : 2D data structure, optional
\begin{quote}

Trajectory of observable in the denominator.
\end{quote}

\textbf{neighbors} : 2D array, optional
\begin{quote}

List showing which states neighbor which.  See neighbors\_harmonic in usutils for explanation.
\end{quote}

\textbf{iat\_method} : string, optional
\begin{quote}

Method used to estimate autocorrelation time.  See the documentation for the avar module.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{errvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the contribution to the error from window i.
\end{quote}

\textbf{iatvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the iat for window i.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{avar\_obs\_diff() (in module avar)}

\begin{fulllineitems}
\phantomsection\label{modules/avar:avar.avar_obs_diff}\pysiglinewithargsret{\code{avar.}\bfcode{avar\_obs\_diff}}{\emph{psis}, \emph{z}, \emph{F}, \emph{f1data}, \emph{g1data}, \emph{f2data=None}, \emph{g2data=None}, \emph{neighbors=None}, \emph{iat\_method='ipce'}}{}
Estimates the asymptotic variance of the estimate of the ratio \(<f_1>/<f_2>-<g_1>/<g_2>\) observables.  If f2data and g2data are not given, they are set to 1.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus.py for a detailed explanation.
\end{quote}

\textbf{z} : 1D array
\begin{quote}

Array containing the normalization constants
\end{quote}

\textbf{F} : 2D array
\begin{quote}

Overlap matrix for the first EMUS iteration.
\end{quote}

\textbf{f1data} : 2D data structure
\begin{quote}

Trajectory of observable in the numerator in the first term of the difference.  First dimension corresponds to the umbrella index and the second to the point in the trajectory.
\end{quote}

\textbf{g1data} : 2D data structure
\begin{quote}

Trajectory of observable in the numerator in the second term of the difference.
\end{quote}

\textbf{f2data} : 2D data structure, optional
\begin{quote}

Trajectory of observable in the denominator in the first term of the difference.
\end{quote}

\textbf{g2data} : 2D data structure, optional
\begin{quote}

Trajectory of observable in the denominator in the second term of the difference.
\end{quote}

\textbf{neighbors} : 2D array, optional
\begin{quote}

List showing which states neighbor which.  See neighbors\_harmonic in usutils for explanation.
\end{quote}

\textbf{iat\_method} : string, optional
\begin{quote}

Method used to estimate autocorrelation time.  See the documentation for the avar module.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{errvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the contribution to the error from window i.
\end{quote}

\textbf{iatvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the iat for window i.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{avar\_zfe() (in module avar)}

\begin{fulllineitems}
\phantomsection\label{modules/avar:avar.avar_zfe}\pysiglinewithargsret{\code{avar.}\bfcode{avar\_zfe}}{\emph{psis}, \emph{z}, \emph{F}, \emph{um1}, \emph{um2}, \emph{neighbors=None}, \emph{iat\_method='ipce'}}{}
Estimates the asymptotic variance in the free energy difference 
between windows um2 and um1, -k\_B T log(z\_2/z\_1). In the code, we
arbitrarily denote um2 as `k' and um1 as `l' for readability.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus.py for a detailed explanation.
\end{quote}

\textbf{z} : 1D array
\begin{quote}

Array containing the normalization constants
\end{quote}

\textbf{F} : 2D array
\begin{quote}

Overlap matrix for the first EMUS iteration.
\end{quote}

\textbf{state\_1} : int
\begin{quote}

Index of the first state.
\end{quote}

\textbf{state\_2} : ind
\begin{quote}

Index of the second state.
\end{quote}

\textbf{neighbors} : 2D array, optional
\begin{quote}

list showing which states neighbor which.  See neighbors\_harmonic in umbrellautils for explanation.
\end{quote}

\textbf{iat\_method} : string, optional
\begin{quote}

Method used to estimate autocorrelation time.  Default is the initial positive correlation estimator (`ipce'), but also supported is the initial convex correlation estimator (`icce') and the acor algorithm (`acor')  See Geyer, Stat. Sci. 1992 and Jonathan Goodman's acor documentation for reference.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{errvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the contribution to the error from window i.
\end{quote}

\textbf{iatvals} : ndarray
\begin{quote}

Array of length L (no. windows) where the i'th value corresponds to the iat for window i.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{getAllocations() (in module avar)}

\begin{fulllineitems}
\phantomsection\label{modules/avar:avar.getAllocations}\pysiglinewithargsret{\code{avar.}\bfcode{getAllocations}}{\emph{importances}, \emph{N\_is}, \emph{newWork}}{}
Calculates the optimal allocation of sample points 
These are the optimal weights for 
To deal with negative weights, it removes all the negative weights, and calculates the weights for the resulting subproblem.

\end{fulllineitems}



\section{emus module}
\label{modules/emus:emus-module}\label{modules/emus:module-emus}\label{modules/emus::doc}\index{emus (module)}
Module containing the emus object.
\index{emus (class in emus)}

\begin{fulllineitems}
\phantomsection\label{modules/emus:emus.emus}\pysiglinewithargsret{\strong{class }\code{emus.}\bfcode{emus}}{\emph{psis}, \emph{cv\_trajs=None}, \emph{neighbors=None}, \emph{k\_B=0.0019872041}}{}
Class containing methods and data for the EMUS algorithm.  An EMUS object has the following data structures which can be interacted with or modified:

self.psis (3D array): array containing values of the biases in each state.
self.cv\_trajs (2D Array): array containing the trajectories in cv space.  None if not used.
self.z (1d array): array containing the normalization constants.  Calculated according to the first iteration of EMUS. 
self.F (2d array): F matrix for the first iteration of EMUS.
self.iats (1d array): array containing integrated autocorrelation times of \(\psi_{ii}(x)\) in each window.
\paragraph{Methods}

\begin{longtable}{ll}
\hline
\endfirsthead

\multicolumn{2}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{2}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


{\hyperref[modules/emus:emus.emus.avar_zfe]{\emph{\code{avar\_zfe}}}}(state\_1, state\_2)
 & 
Calculates the asymptotic variance for the free energy difference between the two states specified.
\\
\hline
{\hyperref[modules/emus:emus.emus.calc_obs]{\emph{\code{calc\_obs}}}}(fdata{[}, z{]})
 & 
Estimates the average of an observable function.
\\
\hline
{\hyperref[modules/emus:emus.emus.calc_pmf]{\emph{\code{calc\_pmf}}}}(domain{[}, cv\_trajs, nbins, kT, z{]})
 & 
Calculates the potential of mean force for the system.
\\
\hline
{\hyperref[modules/emus:emus.emus.calc_zs]{\emph{\code{calc\_zs}}}}({[}nMBAR, tol, use\_iats, iats{]})
 & 
Calculates the normalization constants for the states.
\\
\hline\end{longtable}

\index{avar\_zfe() (emus.emus method)}

\begin{fulllineitems}
\phantomsection\label{modules/emus:emus.emus.avar_zfe}\pysiglinewithargsret{\bfcode{avar\_zfe}}{\emph{state\_1}, \emph{state\_2}}{}
Calculates the asymptotic variance for the free energy difference between the two states specified.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{state\_1} : int
\begin{quote}

Index of the first state.
\end{quote}

\textbf{state\_2} : int
\begin{quote}

Index of the second state.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{errs} : 1D array
\begin{quote}

Array containing each state's contribution to the asymptotic error.  The total asymptotic error is taken by summing the entries.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_obs() (emus.emus method)}

\begin{fulllineitems}
\phantomsection\label{modules/emus:emus.emus.calc_obs}\pysiglinewithargsret{\bfcode{calc\_obs}}{\emph{fdata}, \emph{z=None}}{}
Estimates the average of an observable function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{fdata} : 2d array-like
\begin{quote}

Two dimensional data structure where the first dimension corresponds to the state index, and the second to the value of the observable at that time point.  Must have the same number of data-points as the collective variable trajectory.
\end{quote}

\textbf{z} : 1D array, optional
\begin{quote}

User-provided values for the normalization constants. If not provided, uses values from the first iteration.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{favg} : float
\begin{quote}

The estimated average of the observable.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_pmf() (emus.emus method)}

\begin{fulllineitems}
\phantomsection\label{modules/emus:emus.emus.calc_pmf}\pysiglinewithargsret{\bfcode{calc\_pmf}}{\emph{domain}, \emph{cv\_trajs=None}, \emph{nbins=100}, \emph{kT=1.0}, \emph{z=None}}{}
Calculates the potential of mean force for the system.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{domain} : tuple
\begin{quote}

Tuple containing the dimensions of the space over which to construct the pmf, e.g. (-180,180) or ((0,1),(-3.14,3.14))
\end{quote}

\textbf{nbins} : int or tuple, optional
\begin{quote}

Number of bins to use.  If int, uses that many bins in each dimension.  If tuple, e.g. (100,20), uses 100 bins in the first dimension and 20 in the second.
\end{quote}

\textbf{cvtrajectories} : 2D array-like, optional
\begin{quote}

Two dimensional data structure with the trajectories in cv space.  The first dimension is the state where the data was collected, and the second is the value in cv space.  If not provided, uses trajectory given in the constructor.
\end{quote}

\textbf{z} : 1D array, optional
\begin{quote}

User-provided values for the normalization constants If not provided, uses values from the first iteration of EMUS.
\end{quote}

\textbf{kT} : float, optional
\begin{quote}

Value of kT to scale the PMF by.  If not provided, set to 1.0
\end{quote}

\item[{Returns}] \leavevmode
\textbf{pmf} : nd array
\begin{quote}

Returns the potential of mean force as a d dimensional array, where d is the number of collective variables.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{calc\_zs() (emus.emus method)}

\begin{fulllineitems}
\phantomsection\label{modules/emus:emus.emus.calc_zs}\pysiglinewithargsret{\bfcode{calc\_zs}}{\emph{nMBAR=0}, \emph{tol=1e-08}, \emph{use\_iats=False}, \emph{iats=None}}{}
Calculates the normalization constants for the states.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{nMBAR} : int, optional (default 0)
\begin{quote}

Maximum number of MBAR iterations to perform.
\end{quote}

\textbf{tol} : float, optional (default 1.0E-8)
\begin{quote}

If the relative residual falls beneath the tolerance, the MBAR iteration is truncated.
\end{quote}

\textbf{use\_iats} : bool, optional
\begin{quote}

If true, estimate integrated autocorrelation time in each MBAR iteration.  Likely unnecessary unless dynamics are expected to be drastically different in each state. If iats is provided, the iteration will use those rather than estimating them in each step.
\end{quote}

\textbf{iats} : 1D array, optional
\begin{quote}

Array of size L (no. states) with values of the integrated autocorrelation time estimated in each state.  These values will be used in each iteration.  Overrides use\_iats.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{z} : 1D array
\begin{quote}

Values for the Normalization constant in each state.
\end{quote}

\textbf{F} : 2D array
\begin{quote}

Matrix to take the eigenvalue of for MBAR.
\end{quote}

iats 1D array
\begin{quote}

Estimated values of the autocorrelation time.  Only returned if use\_iats is true.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{emusroutines module}
\label{modules/emusroutines:module-emusroutines}\label{modules/emusroutines::doc}\label{modules/emusroutines:emusroutines-module}\index{emusroutines (module)}
Container for the primary EMUS routines.
\index{calc\_obs() (in module emusroutines)}

\begin{fulllineitems}
\phantomsection\label{modules/emusroutines:emusroutines.calc_obs}\pysiglinewithargsret{\code{emusroutines.}\bfcode{calc\_obs}}{\emph{psis}, \emph{z}, \emph{f1data}, \emph{f2data=None}}{}
Estimates the value of an observable or ratio of observables.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus.py for a detailed explanation.
\end{quote}

\textbf{z} : 1D array
\begin{quote}

Array containing the normalization constants
\end{quote}

\textbf{f1data} : 2D data structure
\begin{quote}

Trajectory of observable in the numerator.  First dimension corresponds to the umbrella index and the second to the point in the trajectory.
\end{quote}

\textbf{f2data} : 2D data structure, optional
\begin{quote}

Trajectory of observable in the denominator.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{avg} : float
\begin{quote}

The estimate of \textless{}f\_1\textgreater{}/\textless{}f\_2\textgreater{}.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{emus\_iter() (in module emusroutines)}

\begin{fulllineitems}
\phantomsection\label{modules/emusroutines:emusroutines.emus_iter}\pysiglinewithargsret{\code{emusroutines.}\bfcode{emus\_iter}}{\emph{psis}, \emph{Avals=None}, \emph{neighbors=None}, \emph{return\_iats=False}, \emph{iat\_method='ipce'}}{}
Performs one step of the the EMUS iteration.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus.py for a detailed explanation.
\end{quote}

\textbf{Avals} : 2D matrix, optional
\begin{quote}

Weights in front of \(\psi\) in the overlap matrix.
\end{quote}

\textbf{neighbors} : 2D array, optional
\begin{quote}

List showing which states neighbor which.  See neighbors\_harmonic in usutils.
\end{quote}

\textbf{return\_iats} : bool, optional
\begin{quote}

Whether or not to calculate integrated autocorrelation times of \(\psi_ii^*\) for each window.
\end{quote}

\textbf{iat\_method} : string, optional
\begin{quote}

Routine to use for calculating said iats.  Accepts `ipce', `acor', and `icce'.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{z} : 1D array
\begin{quote}

Normalization constants for each state
\end{quote}

\textbf{F} : 2D array
\begin{quote}

The overlap matrix constructed for the eigenproblem.
\end{quote}

\textbf{iats} : 1D array
\begin{quote}

If return\_iats chosen, returns the iats that have been estimated.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_pmf() (in module emusroutines)}

\begin{fulllineitems}
\phantomsection\label{modules/emusroutines:emusroutines.make_pmf}\pysiglinewithargsret{\code{emusroutines.}\bfcode{make\_pmf}}{\emph{cv\_trajs}, \emph{psis}, \emph{domain}, \emph{z}, \emph{nbins=100}, \emph{kT=1.0}}{}
Calculates the free energy surface for an umbrella sampling run.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{cv\_trajs} : 2D data structure
\begin{quote}

Data structure containing trajectories in the collective variable space.  See documentation in emus object for more detail.
\end{quote}

\textbf{psis} : 3D data structure
\begin{quote}

Data structure containing psi values.  See documentation in emus object for a detailed explanation.
\end{quote}

\textbf{domain} : tuple
\begin{quote}

Tuple containing the dimensions of the space over which to construct the pmf, e.g. (-180,180) or ((0,1),(-3.14,3.14)) z (1D array or list): Normalization constants for each state
\end{quote}

\textbf{nbins} : int or tuple, optional
\begin{quote}

Number of bins to use.  If int, uses that many bins in each dimension.  If tuple, e.g. (100,20), uses 100 bins in the first dimension and 20 in the second.
\end{quote}

\textbf{kT} : float, optional
\begin{quote}

Value of kT to scale the PMF by.  If not provided, set to 1.0
\end{quote}

\item[{Returns}] \leavevmode
\textbf{pmf} : nd array
\begin{quote}

Returns the potential of mean force as a d dimensional array, where d is the number of collective variables.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{linalg module}
\label{modules/linalg::doc}\label{modules/linalg:module-linalg}\label{modules/linalg:linalg-module}\index{linalg (module)}
Collection of linear algebra routines used in the EMUS algorithm and
associated error analysis.
\index{groupInverse() (in module linalg)}

\begin{fulllineitems}
\phantomsection\label{modules/linalg:linalg.groupInverse}\pysiglinewithargsret{\code{linalg.}\bfcode{groupInverse}}{\emph{M}}{}
Computes the group inverse of stochastic matrix using the algorithm
given by Golub and Meyer in:
G. H. Golub and C. D. Meyer, Jr, SIAM J. Alg. Disc. Meth. 7, 273-
281 (1986)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{M} : ndarray
\begin{quote}

A square matrix with index 1.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{grpInvM} : ndarray
\begin{quote}

The group inverse of M.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{old\_stationary\_distrib() (in module linalg)}

\begin{fulllineitems}
\phantomsection\label{modules/linalg:linalg.old_stationary_distrib}\pysiglinewithargsret{\code{linalg.}\bfcode{old\_stationary\_distrib}}{\emph{F}, \emph{fix=None}, \emph{residtol=1e-10}, \emph{max\_iter=100}}{}
\end{fulllineitems}

\index{stationary\_distrib() (in module linalg)}

\begin{fulllineitems}
\phantomsection\label{modules/linalg:linalg.stationary_distrib}\pysiglinewithargsret{\code{linalg.}\bfcode{stationary\_distrib}}{\emph{F}, \emph{residtol=1e-10}, \emph{max\_iter=100}}{}
Calculates the eigenvector of the matrix F with eigenvalue 1 (if it exists).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{F} : ndarray
\begin{quote}

A matrix known to have a single left eigenvector with 
eigenvalue 1.
\end{quote}

\textbf{residtol} : float or scalar
\begin{quote}

To improve the accuracy of the computation, the algorithm will
``polish'' the final result using several iterations of the power
method, z\textasciicircum{}T F = z\textasciicircum{}T.  Residtol gives the tolerance for the 
associated relative residual to determine convergence.
\end{quote}

\textbf{maxiter} : int
\begin{quote}

Maximum number of iterations to use the power method to reduce
the residual.  In practice, should never be reached.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{z} : ndarray
\begin{quote}

The eigenvector of the matrix F with eigenvalue 1.  For a Markov
chain stationary distribution, this is the stationary distribution.
Normalization is chosen s.t. entries sum to one.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\section{usutils module}
\label{modules/usutils:usutils-module}\label{modules/usutils::doc}\label{modules/usutils:module-usutils}\index{usutils (module)}
Module containing methods useful for analyzing umbrella sampling 
calculations that do not rely directly on the EMUS estimator.
\index{calc\_harmonic\_psis() (in module usutils)}

\begin{fulllineitems}
\phantomsection\label{modules/usutils:usutils.calc_harmonic_psis}\pysiglinewithargsret{\code{usutils.}\bfcode{calc\_harmonic\_psis}}{\emph{cv\_traj}, \emph{centers}, \emph{fks}, \emph{kTs}, \emph{period=None}}{}
Calculates the values of each bias function from a trajectory of points
in a single state.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{cv\_traj} : array-like
\begin{quote}

Trajectory in collective variable space.  Can be 1-dimensional (one cv) or 2-dimensional (many cvs).  The first dimension is the time index, and (optional) second corresponds to the collective variable.
\end{quote}

\textbf{centers} : array-like
\begin{quote}

The locations of the centers of each window.  The first dimension is the window index, and the (optional) second is the collective variable index.
\end{quote}

\textbf{fks} : scalar or 2darray
\begin{quote}

If array or list, data structure where the first dimension corresponds to the window index and the second corresponds to the collective variable.  If scalar, windows are assumed to have that force constant in every dimension.
\end{quote}

\textbf{kTs} : scalar or 2darray
\begin{quote}

1D array with the Boltzmann factor or a single value which will be used in all windows.  Default value is the scalar 1.
\end{quote}

\textbf{period} : 1D array-like or float, optional
\begin{quote}

Period of the collective variable e.g. 360 for an angle. If None, all collective variables are taken to be aperiodic.  If scalar, assumed to be period of each collective variable. If 1D iterable with each value a scalar or None, each cv has periodicity of that size.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{psis} : 2D array
\begin{quote}

The values of the bias functions at each point in the trajectory evaluated at the windows given.  First axis corresponds to the timepoint, the second to the window index.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{data\_from\_WHAMmeta() (in module usutils)}

\begin{fulllineitems}
\phantomsection\label{modules/usutils:usutils.data_from_WHAMmeta}\pysiglinewithargsret{\code{usutils.}\bfcode{data\_from\_WHAMmeta}}{\emph{filepath}, \emph{dim}, \emph{T=None}, \emph{k\_B=0.0019872041}, \emph{period=None}}{}
Reads data saved on disk according to the format used by the WHAM implementation by Grossfield.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filepath} : string
\begin{quote}

The path to the meta file.
\end{quote}

\textbf{dim} : int
\begin{quote}

The number of dimensions of the cv space.
\end{quote}

\textbf{T} : scalar, optional
\begin{quote}

Temperature of the system.
\end{quote}

\textbf{k\_B} : scalar, optional
\begin{quote}

Boltzmann Constant for the system. Default is in kCal/mol
\end{quote}

\textbf{period} : 1D array-like or float, optional
\begin{quote}

Variable with the periodicity information of the system.  See the Data Structures section of the documentation for a detailed explanation.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{psis} : 2D array
\begin{quote}

The values of the bias functions at each point in the trajectory evaluated at the windows given.  First axis corresponds to the timepoint, the second to the window index.
\end{quote}

\textbf{cv\_trajs} : 2D array-like
\begin{quote}

Two dimensional data structure with the trajectories in cv space.  The first dimension is the state where the data was collected, and the second is the value in cv space.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{neighbors\_harmonic() (in module usutils)}

\begin{fulllineitems}
\phantomsection\label{modules/usutils:usutils.neighbors_harmonic}\pysiglinewithargsret{\code{usutils.}\bfcode{neighbors\_harmonic}}{\emph{centers}, \emph{fks}, \emph{kTs=1.0}, \emph{period=None}, \emph{nsig=4}}{}
Calculates neighborlist for harmonic windows.  Neighbors are chosen 
such that neighboring umbrellas are no more than nsig standard
deviations away on a flat potential.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{centers} : 2darray
\begin{quote}

The locations of the centers of each window.  The
first dimension is the window index, and the second
is the collective variable index.
\end{quote}

\textbf{fks} : 2darray or scalar
\begin{quote}

If array or list, data structure where the first dimension 
corresponds to the window index and the second corresponds to the
collective variable.  If scalar, windows are assumed to have that 
force constant in every dimension.
\end{quote}

\textbf{kTs} : 2darray or float
\begin{quote}

1D array with the Boltzmann factor or
a single value which will be used in all windows.  Default
value is the scalar 1.
\end{quote}

\textbf{period} : 1D array-like or float
\begin{quote}

Period of the collective variable
e.g. 360 for an angle. If None, all collective variables are 
taken to be aperiodic.  If scalar, assumed to be period of each 
collective variable. If 1D iterable with each value a scalar or 
None, each cv has periodicity of that size.
\end{quote}

\textbf{nsig} : scalar
\begin{quote}

Number of standard deviations of the gaussians to 
include in the neighborlist.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{nbrs} : 2d list
\begin{quote}

List where element i is a list with the indices of all 
windows neighboring window i.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_metafile() (in module usutils)}

\begin{fulllineitems}
\phantomsection\label{modules/usutils:usutils.parse_metafile}\pysiglinewithargsret{\code{usutils.}\bfcode{parse\_metafile}}{\emph{filepath}, \emph{dim}}{}
Parses the meta file located at filepath. Assumes Wham-like Syntax.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{filepath} : string
\begin{quote}

The path to the meta file.
\end{quote}

\textbf{dim} : int
\begin{quote}

The number of dimensions of the cv space.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{traj\_paths} : list of strings
\begin{quote}

A list containing the paths to the trajectories for each window.
\end{quote}

\textbf{centers} : 2D array of floats
\begin{quote}

Array with the center of each harmonic window. See calc\_harm\_psis for syntax.
\end{quote}

\textbf{fks} : 2D array of floats
\begin{quote}

Array with the force constants for each harmonic window. See calc\_harm\_psis for syntax.
\end{quote}

\textbf{iats} : 1D array of floats or None
\begin{quote}

Array with the integrated autocorrelation times of each window.  None if not given in 
the meta file
\end{quote}

\textbf{temps} : 1D array of floats or None
\begin{quote}

Array with the temperature of each window in the umbrella sampling calculation.  If not given in the meta file, this will just be None.
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}

\index{unpackNbrs() (in module usutils)}

\begin{fulllineitems}
\phantomsection\label{modules/usutils:usutils.unpackNbrs}\pysiglinewithargsret{\code{usutils.}\bfcode{unpackNbrs}}{\emph{compd\_array}, \emph{neighbors}, \emph{L}}{}
Unpacks an array of neighborlisted data.  Currently, assumes axis 0
is the compressed axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{compd\_array} : array-like
\begin{quote}

The compressed array, calculated using neighborlists
\end{quote}

\textbf{neighbors} : array-like
\begin{quote}

The list or array of ints, containing the indices of the neighboring windows
\end{quote}

\textbf{L} : int
\begin{quote}

The total number of windows.
\end{quote}

\item[{Returns}] \leavevmode
\textbf{expd\_array} : array-like
\begin{quote}

The expanded array of data
\end{quote}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{test}
\label{test:test}\label{test::doc}
test

\footnote{
This footnote is labeled manually, so its number is fixed.
} will be ``2'' (manually numbered),
\footnote{
This footnote will be labeled ``3''.  It is the second
auto-numbered footnote, but footnote label ``2'' is already used.
} will be ``3'' (anonymous auto-numbered), and
\footnote{\begin{description}
\item[{This autonumber-labeled footnote will be labeled ``1''.}] \leavevmode
It is the first auto-numbered footnote and no other footnote

\end{description}

with label ``1'' exists.  The order of the footnotes is used to
determine numbering, not the order of the footnote references.
} will be ``1'' (labeled auto-numbered).


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{a}
\item {\texttt{autocorrelation}}, \pageref{modules/autocorrelation:module-autocorrelation}
\item {\texttt{avar}}, \pageref{modules/avar:module-avar}
\indexspace
\bigletter{e}
\item {\texttt{emus}}, \pageref{modules/emus:module-emus}
\item {\texttt{emusroutines}}, \pageref{modules/emusroutines:module-emusroutines}
\indexspace
\bigletter{l}
\item {\texttt{linalg}}, \pageref{modules/linalg:module-linalg}
\indexspace
\bigletter{u}
\item {\texttt{usutils}}, \pageref{modules/usutils:module-usutils}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
