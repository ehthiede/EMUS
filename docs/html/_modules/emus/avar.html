

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>emus.avar &mdash; emus  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> emus
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datastructures.html">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">EMUS Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">emus</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>emus.avar</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for emus.avar</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; Library with routines associated with the asymptotic variance of the first EMUS iteration.  These estimates rely on estimates of the autocorrelation time of observables.  Multiple methods for estimating autocorrelation times are supported, these include the initial positive correlation estimator (&#39;ipce&#39;) and the initial convex correlation estimator (&#39;icce&#39;) by Geyer, and the acor algorithm (&#39;acor&#39;) by Jonathan Goodman.  See the documentation to the `autocorrelation module &lt;autocorrelation.html&gt;`__ for more details.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">lm</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">emus</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">autocorrelation</span> <span class="k">as</span> <span class="n">ac</span>
<span class="kn">from</span> <span class="nn">._defaults</span> <span class="k">import</span> <span class="n">DEFAULT_IAT</span><span class="p">,</span> <span class="n">DEFAULT_KT</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="calc_avg_ratio"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.calc_avg_ratio">[docs]</a><span class="k">def</span> <span class="nf">calc_avg_ratio</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the asymptotic variance in the estimate of :math:`&lt;g_1&gt;/&lt;g_2&gt;`. If :math:`g_2` is not given, it just calculates the asymptotic variance associated with the average of :math:`g_1`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        Overlap matrix for the first EMUS iteration.</span>
<span class="sd">    g1data : 2D data structure</span>
<span class="sd">        Trajectory of observable in the numerator.  First dimension corresponds to the window index and the second to the point in the trajectory.</span>
<span class="sd">    g2data : 2D data structure, optional</span>
<span class="sd">        Trajectory of observable in the denominator of the ratio.  If not provided, taken to be all ones.</span>
<span class="sd">    neighbors : 2D array, optional</span>
<span class="sd">        List showing which windows neighbor which.  Element i,j is the j&#39;th neighboring window of window i.</span>
<span class="sd">    iat_method : string or 1D array-like, optional</span>
<span class="sd">        Method used to estimate autocorrelation time.  Choices are &#39;acor&#39;, &#39;ipce&#39;, and &#39;icce&#39;.  Alternatively, if an array of length no. windows is provided, element i is taken to be the autocorrelation time of window i.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iats : ndarray</span>
<span class="sd">        Array of length L (no. windows) where the i&#39;th value corresponds to the iat for window i&#39;s contribution to the error.</span>
<span class="sd">    mean : scalar</span>
<span class="sd">        Estimate of the ratio</span>
<span class="sd">    variances : ndarray</span>
<span class="sd">        Array of length L (no. windows) where the i&#39;th value corresponds to the autocovariance corresponding to window i&#39;s contribution to the error.  The total autocavariance of the ratio can be calculated by summing over the array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># Clean the input and set defaults</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">g1data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g1i</span><span class="p">)</span> <span class="k">for</span> <span class="n">g1i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">g2data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">g1data_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">g1data_i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>

    <span class="c1"># Compute average of functions in each window.</span>
    <span class="n">g1star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g2star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g2data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g1avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g1star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">g2avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="c1"># Compute partial derivatives</span>
    <span class="n">gI</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">groupInverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>
    <span class="n">dBdF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gI</span><span class="p">,</span> <span class="n">g1star</span> <span class="o">-</span> <span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span> <span class="o">*</span> <span class="n">g2star</span><span class="p">))</span> <span class="o">/</span> <span class="n">g2avg</span>
    <span class="n">dBdg1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
    <span class="n">dBdg2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
    <span class="n">iats</span><span class="p">,</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">_calculate_acovar</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">dBdF</span><span class="p">,</span> <span class="p">(</span><span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="p">),</span> <span class="p">(</span><span class="n">dBdg1</span><span class="p">,</span> <span class="n">dBdg2</span><span class="p">),</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iats</span><span class="p">,</span> <span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">,</span> <span class="n">variances</span></div>


<div class="viewcode-block" id="calc_log_avg"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.calc_log_avg">[docs]</a><span class="k">def</span> <span class="nf">calc_log_avg</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the asymptotic variance in the EMUS estimate of :math:`-log &lt;g_1&gt;/&lt;g_2&gt;`.  If :math:`g_2` data is not provided, it estimates the asymptotic variance in the estimate of :math:`-log &lt;g_1&gt;/&lt;g_2&gt;`.  Input and output is as in average_ratio.  Note that if this is used for free energy differences, the result does not use the Boltzmann factor (i.e. :math:`k_B T=1`).  In that case, resulting variances should be scaled by the Boltzmann factor *squared*.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Clean the input and set defaults</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">g1data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g1i</span><span class="p">)</span> <span class="k">for</span> <span class="n">g1i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">g2data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">g1data_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">g1data_i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>

    <span class="c1"># Compute average of functions in each window.</span>
    <span class="n">g1star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g2star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g2data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g1avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g1star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">g2avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="c1"># Compute partial derivatives</span>
    <span class="n">gI</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">groupInverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>
    <span class="n">dBdF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gI</span><span class="p">,</span> <span class="n">g1star</span> <span class="o">/</span> <span class="n">g1avg</span> <span class="o">-</span> <span class="n">g2star</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">))</span>
    <span class="n">dBdg1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g1avg</span>
    <span class="n">dBdg2</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
    <span class="n">iats</span><span class="p">,</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">_calculate_acovar</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">dBdF</span><span class="p">,</span> <span class="p">(</span><span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="p">),</span> <span class="p">(</span><span class="n">dBdg1</span><span class="p">,</span> <span class="n">dBdg2</span><span class="p">),</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">iats</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">),</span> <span class="n">variances</span></div>


<div class="viewcode-block" id="calc_avg_on_pmf"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.calc_avg_on_pmf">[docs]</a><span class="k">def</span> <span class="nf">calc_avg_on_pmf</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">,</span> <span class="n">psis</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the asymptotic variance of an average on a pmf.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cv_trajs : 2D data structure</span>
<span class="sd">        Data structure containing trajectories in the collective variable space.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    domain : tuple</span>
<span class="sd">        Tuple containing the dimensions of the space over which to construct the pmf, e.g. (-180,180) or ((0,1),(-3.14,3.14)) z (1D array or list): Normalization constants for each window</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        Overlap matrix for the first EMUS iteration.</span>
<span class="sd">    g1data : 2D data structure</span>
<span class="sd">        Trajectory of the observable in the numerator.  First dimension corresponds to the window index and the second to the point in the trajectory.</span>
<span class="sd">    g2data : 2D data structure, optional</span>
<span class="sd">        Trajectory of observable in the denominator of the ratio.  If not provided, taken to be all ones.</span>
<span class="sd">    neighbors : 2D array-like, optional</span>
<span class="sd">        List showing which windows neighbor which.  See neighbors_harmonic in usutils.</span>
<span class="sd">    nbins : int or tuple, optional</span>
<span class="sd">        Number of bins to use.  If int, uses that many bins in each dimension.  If tuple, e.g. (100,20), uses 100 bins in the first dimension and 20 in the second.</span>
<span class="sd">    iat_method : string or 1D array-like, optional</span>
<span class="sd">        Method used to estimate autocorrelation time.  Choices are &#39;acor&#39;, &#39;ipce&#39;, and &#39;icce&#39;.  Alternatively, if an array of length no. windows is provided, element i is taken to be the autocorrelation time of window i.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Clean the input and set defaults</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)))</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># Make nbins to an iterable in the 1d case.</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">nbins</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndims</span>
    <span class="k">if</span> <span class="n">g2data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">g1data_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">g1data_i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
    <span class="n">g1data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g1_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">g1_i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
    <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g2_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">g2_i</span> <span class="ow">in</span> <span class="n">g2data</span><span class="p">]</span>

    <span class="c1"># Warn user if they want to calculate each autocorrelation by hand.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iat_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Programs is set to compute the iat for every observable.  Since for a potential of mean force each point is an observable, this is going to be REALLY SLOW.  It is strongly suggested that you compute representative autocorrelation times for each window, and use those instead.&quot;</span><span class="p">)</span>

    <span class="c1"># Get the edges for each histogram bin</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nbins</span><span class="p">)]</span>

    <span class="c1"># Get Group Inverse for the matrix</span>
    <span class="n">gI</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">groupInverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>

    <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="n">avars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="c1"># Iterate over histogram_bins.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">avars</span><span class="p">):</span>
        <span class="n">g1data_hist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">g2data_hist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">traj</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">traj</span><span class="p">])</span>
            <span class="n">inbin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">edge_d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                <span class="n">hd_ndx</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="n">inhist_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">edge_d</span><span class="p">[</span><span class="n">hd_ndx</span><span class="p">])</span>
                <span class="n">inhist_d</span> <span class="o">*=</span> <span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">edge_d</span><span class="p">[</span><span class="n">hd_ndx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">inbin</span> <span class="o">*=</span> <span class="n">inhist_d</span>
            <span class="n">g1data_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inbin</span> <span class="o">*</span> <span class="n">g1data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">g2data_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inbin</span> <span class="o">*</span> <span class="n">g2data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">g1star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
            <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g1data_hist</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g1avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g1star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">g2star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
            <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g2data_hist</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g2avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">dBdF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gI</span><span class="p">,</span> <span class="n">g1star</span> <span class="o">-</span> <span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span> <span class="o">*</span> <span class="n">g2star</span><span class="p">))</span> <span class="o">/</span> <span class="n">g2avg</span>
        <span class="n">dBdg1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
        <span class="n">dBdg2</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
        <span class="n">iats</span><span class="p">,</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">_calculate_acovar</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">dBdF</span><span class="p">,</span> <span class="p">(</span><span class="n">g1data_hist</span><span class="p">,</span> <span class="n">g2data_hist</span><span class="p">),</span> <span class="p">(</span>
            <span class="n">dBdg1</span><span class="p">,</span> <span class="n">dBdg2</span><span class="p">),</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
        <span class="n">avars</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">variances</span><span class="p">)</span>
        <span class="n">means</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">g1avg</span> <span class="o">/</span> <span class="n">g2avg</span>
    <span class="k">return</span> <span class="n">means</span><span class="p">,</span> <span class="n">avars</span></div>


<div class="viewcode-block" id="calc_pmf"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.calc_pmf">[docs]</a><span class="k">def</span> <span class="nf">calc_pmf</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">,</span> <span class="n">psis</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">g2data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">kT</span><span class="o">=</span><span class="n">DEFAULT_KT</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the asymptotic variance of a free energy surface.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cv_trajs : 2D data structure</span>
<span class="sd">        Data structure containing trajectories in the collective variable space.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    domain : tuple</span>
<span class="sd">        Tuple containing the dimensions of the space over which to construct the pmf, e.g. (-180,180) or ((0,1),(-3.14,3.14)) z (1D array or list): Normalization constants for each window</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        Overlap matrix for the first EMUS iteration.</span>
<span class="sd">    neighbors : 2D array-like, optional</span>
<span class="sd">        List showing which windows neighbor which.  See neighbors_harmonic in usutils.</span>
<span class="sd">    nbins : int or tuple, optional</span>
<span class="sd">        Number of bins to use.  If int, uses that many bins in each dimension.  If tuple, e.g. (100,20), uses 100 bins in the first dimension and 20 in the second.</span>
<span class="sd">    kT : float, optional</span>
<span class="sd">        Value of kT to scale the PMF by.  If not provided, set to the default value.</span>
<span class="sd">    iat_method : string or 1D array-like, optional</span>
<span class="sd">        Method used to estimate autocorrelation time.  Choices are &#39;acor&#39;, &#39;ipce&#39;, and &#39;icce&#39;.  Alternatively, if an array of length no. windows is provided, element i is taken to be the autocorrelation time of window i.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fes : ndarray</span>
<span class="sd">        Value of the free energy in each histogram bin.</span>
<span class="sd">    avars : ndarray</span>
<span class="sd">        Asymptotic variance of each histogram bin.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Clean the input and set defaults</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)))</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># Make nbins to an iterable in the 1d case.</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">nbins</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndims</span>
    <span class="k">if</span> <span class="n">g2data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">))</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">cv_trajs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iat_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Programs is set to compute the iat for every observable.  Since for a potential of mean force each point is an observable, this is going to be REALLY SLOW.  It is strongly suggested that you compute representative autocorrelation times for each window, and use those instead.&quot;</span><span class="p">)</span>

    <span class="c1"># Get the edges for each histogram bin</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nbins</span><span class="p">)]</span>

    <span class="c1"># Calculate quantities used for each histogram bin.</span>
    <span class="n">gI</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">groupInverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>
    <span class="n">g2star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
        <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g2data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g2avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="n">fes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="n">avars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="c1"># Iterate over histogram_bins.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">aval</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">avars</span><span class="p">):</span>
        <span class="c1"># Find part of trajectory inside the histogram bin.</span>
        <span class="n">g1data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">traj</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">traj</span><span class="p">])</span>
            <span class="n">g1_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">edge_d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                <span class="n">hd_ndx</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="n">inhist_d</span> <span class="o">=</span> <span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">edge_d</span><span class="p">[</span><span class="n">hd_ndx</span><span class="p">])</span>
                <span class="n">inhist_d</span> <span class="o">*=</span> <span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="n">d</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">edge_d</span><span class="p">[</span><span class="n">hd_ndx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">g1_i</span> <span class="o">*=</span> <span class="n">inhist_d</span>
            <span class="n">g1data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1_i</span><span class="p">)</span>
        <span class="n">dA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([(</span><span class="n">edg_i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">edg_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">edg_i</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>

        <span class="n">g1star</span> <span class="o">=</span> <span class="n">emus</span><span class="o">.</span><span class="n">_calculate_win_avgs</span><span class="p">(</span>
            <span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">g1data</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">use_iter</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">g1avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g1star</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">dBdF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gI</span><span class="p">,</span> <span class="n">g1star</span> <span class="o">/</span> <span class="n">g1avg</span> <span class="o">-</span> <span class="n">g2star</span> <span class="o">/</span> <span class="n">g2avg</span><span class="p">))</span>
        <span class="n">dBdg1</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">g1avg</span>
        <span class="n">dBdg2</span> <span class="o">=</span> <span class="o">-</span><span class="n">z</span> <span class="o">/</span> <span class="n">g2avg</span>
        <span class="n">iats</span><span class="p">,</span> <span class="n">variances</span> <span class="o">=</span> <span class="n">_calculate_acovar</span><span class="p">(</span>
            <span class="n">psis</span><span class="p">,</span> <span class="n">dBdF</span><span class="p">,</span> <span class="p">(</span><span class="n">g1data</span><span class="p">,</span> <span class="n">g2data</span><span class="p">),</span> <span class="p">(</span><span class="n">dBdg1</span><span class="p">,</span> <span class="n">dBdg2</span><span class="p">),</span> <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
        <span class="n">avars</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">variances</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">kT</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">fes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">kT</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">g1avg</span> <span class="o">/</span> <span class="p">(</span><span class="n">dA</span> <span class="o">*</span> <span class="n">g2avg</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fes</span><span class="p">,</span> <span class="n">avars</span></div>


<div class="viewcode-block" id="calc_partition_functions"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.calc_partition_functions">[docs]</a><span class="k">def</span> <span class="nf">calc_partition_functions</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the asymptotic variance of the partition function (normalization constant) for each window.  To get an estimate of the autocovariance of the free energy for each window, multiply the autocovariance of window :math:`i` by :math:` (k_B T / z_i)^2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        Overlap matrix for the first EMUS iteration.</span>
<span class="sd">    neighbors : 2D array, optional</span>
<span class="sd">        List showing which windows neighbor which.  See neighbors_harmonic in usutils for explanation.</span>
<span class="sd">    iat_method : string or 1D array-like, optional</span>
<span class="sd">        Method used to estimate autocorrelation time.  See the documentation above.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    autocovars : ndarray</span>
<span class="sd">        Array of length L (no. windows) where the i&#39;th value corresponds to the autocovariance estimate for :math:`z_i`</span>
<span class="sd">    z_var_contribs : ndarray</span>
<span class="sd">        Two dimensional array, where element i,j corresponds to window j&#39;s contribution to the autocovariance of window i.</span>
<span class="sd">    z_var_iats : ndarray</span>
<span class="sd">        Two dimensional array, where element i,j corresponds to the autocorrelation time associated with window j&#39;s contribution to the autocovariance of window i.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">z_var_contribs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
    <span class="n">z_var_iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iat_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">iat_routine</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">_get_iat_method</span><span class="p">(</span><span class="n">iat_method</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Try to interpret iat_method as a collection of numbers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iat_method</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">err</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Was unable to interpret the input provided as a method to calculate the autocorrelation time or as a sequence of autocorrelation times.  Original error message follows: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span>
        <span class="n">iat_routine</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iats</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;IAT Input was interpreted to be a collection of precomputed autocorrelation times.  However, the number of autocorrelation times found (</span><span class="si">%d</span><span class="s1">) is not equal to the number of states (</span><span class="si">%d</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iats</span><span class="p">),</span> <span class="n">L</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># If no neighborlist, assume all windows neighbor</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">groupInv</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">groupInverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="n">F</span><span class="p">)</span>
    <span class="c1"># Calculate the partial derivatives of z .</span>
    <span class="c1"># (i,j,k)&#39;th element is partial of z_k w.r.t. F_ij</span>
    <span class="n">dzdFij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">groupInv</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>

    <span class="c1"># Iterate over windows, getting err contribution from sampling in each</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">psi_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psis</span><span class="p">):</span>
        <span class="c1"># Data cleaning</span>
        <span class="n">psi_i_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psi_i</span><span class="p">)</span>
        <span class="n">Lneighb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>  <span class="c1"># Number of neighbors</span>

        <span class="c1"># Normalize psi_j(x_i^t) for all j</span>
        <span class="n">psi_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psi_i_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">normedpsis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psi_i_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># psi_j / sum_k psi_k</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Lneighb</span><span class="p">):</span>
            <span class="n">normedpsis</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">psi_i_arr</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">psi_sum</span>

        <span class="c1"># Calculate contribution to as. err. for each z_k</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">dzkdFij</span> <span class="o">=</span> <span class="n">dzdFij</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">err_t_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normedpsis</span><span class="p">,</span> <span class="n">dzkdFij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">iat_routine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">iat</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">iat_routine</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">)</span>
                <span class="n">z_var_contribs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">sigma</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iat</span> <span class="o">=</span> <span class="n">iats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">z_var_contribs</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span>
                    <span class="n">err_t_series</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">iat</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">))</span>
            <span class="n">z_var_iats</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iat</span>
    <span class="n">autocovars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_var_contribs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">autocovars</span><span class="p">,</span> <span class="n">z_var_contribs</span><span class="p">,</span> <span class="n">z_var_iats</span></div>


<span class="k">def</span> <span class="nf">_calculate_acovar</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">dBdF</span><span class="p">,</span> <span class="n">gdata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dBdg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimates the autocovariance and autocorrelation times for each window&#39;s contribution to the autocovariance of some observable B.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    dBdF : array-like</span>
<span class="sd">        Two dimensional array, where element :math:`i,j` is the derivative of the estimate of B with respect to :math:`F_{ij}`</span>
<span class="sd">    gdata : array-like, optional</span>
<span class="sd">        Three dimensional data structure containing data from various observables.  The first index n</span>
<span class="sd">    dBdg : array-like, optional</span>
<span class="sd">        Two dimensional array, where element :math:`n,j` is the derivative of the estimate of B with respect to :math:`gn_j^*`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    iats : 1d array</span>
<span class="sd">        The value of the autocorrelation time for each trajectory.</span>
<span class="sd">    avars : 1d array</span>
<span class="sd">        Each window&#39;s contribution to the asymptotic variance.  Summing over windows gives the asymptotic variance of the system.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gdata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdata</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dBdg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Function data provided is mismatched with derivatives: respective sizes are &#39;</span><span class="p">,</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">gdata</span><span class="p">),</span> <span class="s1">&#39; and &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dBdg</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">dBdF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dBdF</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iat_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">iat_routine</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">_get_iat_method</span><span class="p">(</span><span class="n">iat_method</span><span class="p">)</span>
        <span class="n">iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Try to interpret iat_method as a collection of numbers</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iat_method</span><span class="p">])</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">err</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;Was unable to interpret the input provided as a method to calculate the autocorrelation time or as a sequence of autocorrelation times.  Original error message follows: &quot;</span> <span class="o">+</span> <span class="n">err</span><span class="o">.</span><span class="n">message</span>
            <span class="k">raise</span> <span class="n">err</span>
        <span class="n">iat_routine</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iats</span><span class="p">)</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;IAT Input was interpreted to be a collection of precomputed autocorrelation times.  However, the number of autocorrelation times found (</span><span class="si">%d</span><span class="s1">) is not equal to the number of states (</span><span class="si">%d</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iats</span><span class="p">),</span> <span class="n">L</span><span class="p">))</span>

    <span class="n">sigmas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">psi_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psis</span><span class="p">):</span>
        <span class="n">nbrs_i</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">denom_i</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">err_t_series</span> <span class="o">=</span> <span class="n">psi_i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">denom_i</span><span class="p">])</span>
        <span class="n">Fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">err_t_series</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="p">(</span><span class="n">psi_i</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="n">denom_i</span><span class="p">])</span> <span class="o">-</span> <span class="n">Fi</span><span class="p">),</span> <span class="n">dBdF</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">nbrs_i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">gdata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">g_n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gdata</span><span class="p">):</span>
                <span class="n">g_ni</span> <span class="o">=</span> <span class="n">g_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dBdg_n</span> <span class="o">=</span> <span class="n">dBdg</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">g_ni_wtd</span> <span class="o">=</span> <span class="n">g_ni</span> <span class="o">*</span> <span class="n">denom_i</span>
                <span class="n">err_t_series</span> <span class="o">+=</span> <span class="n">dBdg_n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">g_ni_wtd</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">g_ni_wtd</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">iat_routine</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iat</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">iat_routine</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">)</span>
            <span class="n">iats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iat</span> <span class="o">=</span> <span class="n">iats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">iat</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">err_t_series</span><span class="p">))</span>
        <span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span>
    <span class="k">return</span> <span class="n">iats</span><span class="p">,</span> <span class="n">sigmas</span><span class="o">**</span><span class="mi">2</span>


<div class="viewcode-block" id="getAllocations"><a class="viewcode-back" href="../../modules/avar.html#emus.avar.getAllocations">[docs]</a><span class="k">def</span> <span class="nf">getAllocations</span><span class="p">(</span><span class="n">importances</span><span class="p">,</span> <span class="n">N_is</span><span class="p">,</span> <span class="n">newWork</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the optimal allocation of sample points</span>
<span class="sd">    These are the optimal weights for</span>
<span class="sd">    To deal with negative weights, it removes all the negative weights, and calculates the weights for the resulting subproblem.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">importances</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">N_is</span><span class="p">)</span>
    <span class="n">testWeights</span> <span class="o">=</span> <span class="n">_calcWeightSubproblem</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">newWork</span><span class="p">)</span>
    <span class="n">negativity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">weit</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">weit</span> <span class="ow">in</span> <span class="n">testWeights</span><span class="p">])</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">negativity</span><span class="p">)):</span>
        <span class="n">errs</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">negativity</span><span class="p">)</span>
        <span class="n">ns</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">negativity</span><span class="p">)</span>
        <span class="n">newWeights</span> <span class="o">=</span> <span class="n">_calcWeightSubproblem</span><span class="p">(</span><span class="n">errs</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">newWork</span><span class="p">)</span>
        <span class="n">testWeights</span> <span class="o">=</span> <span class="n">newWeights</span>
        <span class="n">negativity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">weit</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">weit</span> <span class="ow">in</span> <span class="n">testWeights</span><span class="p">])</span>
    <span class="c1"># We return the weights, rounded and then converted to integers</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">round</span><span class="p">,</span> <span class="n">testWeights</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_calcWeightSubproblem</span><span class="p">(</span><span class="n">importances</span><span class="p">,</span> <span class="n">N_is</span><span class="p">,</span> <span class="n">newWork</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the sampling weights of each region, according to the method using Lagrange Modifiers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">totalWork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">N_is</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">importances</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">varConstants</span> <span class="o">=</span> <span class="n">importances</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N_is</span><span class="p">)</span>
    <span class="n">constSum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">varConstants</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">varConstants</span><span class="p">):</span>
        <span class="n">weights</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">/</span> <span class="n">constSum</span> <span class="o">*</span> <span class="p">(</span><span class="n">newWork</span> <span class="o">+</span> <span class="n">totalWork</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_is</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">weights</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Erik H Thiede.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>