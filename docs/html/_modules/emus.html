

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>emus &mdash; emus  documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700&subset=latin,cyrillic' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="emus  documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
          <a href="../index.html" class="fa fa-home"> emus</a>
        
        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../theory.html">Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../theory.html#basics-of-equilibrium-umbrella-sampling">Basics of Equilibrium Umbrella Sampling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../theory.html#emus">EMUS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart.html">Quickstart</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html#loading-from-wham-like-formats">Loading from WHAM-like Formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html#calculating-the-pmf">Calculating the PMF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html#estimating-window-partition-functions">Estimating Window Partition Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quickstart.html#calculating-averages">Calculating Averages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../datastructures.html">Data Structures</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../datastructures.html#common-data-structures">Common data structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../datastructures.html#parameters-for-harmonic-windows">Parameters for Harmonic windows</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/index.html">EMUS Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../modules/autocorrelation.html">autocorrelation module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/avar.html">avar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/emus.html">emus module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/linalg.html">linalg module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../modules/usutils.html">usutils module</a></li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">emus</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>emus</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for emus</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; Container for the primary EMUS routines.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">linalg</span> <span class="kn">as</span> <span class="nn">lm</span>
<span class="kn">import</span> <span class="nn">autocorrelation</span> <span class="kn">as</span> <span class="nn">ac</span>
<span class="kn">from</span> <span class="nn">usutils</span> <span class="kn">import</span> <span class="n">unpackNbrs</span>
<span class="kn">from</span> <span class="nn">_defaults</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="calculate_obs"><a class="viewcode-back" href="../modules/emus.html#emus.calculate_obs">[docs]</a><span class="k">def</span> <span class="nf">calculate_obs</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">g1data</span><span class="p">,</span><span class="n">g2data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates the value of an observable or ratio of observables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    g1data : 2D data structure</span>
<span class="sd">        Trajectory of observable in the numerator.  First dimension corresponds to the window index and the second to the point in the trajectory.</span>
<span class="sd">    g2data : 2D data structure, optional</span>
<span class="sd">        Trajectory of observable in the denominator.  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    avg : float</span>
<span class="sd">        The estimate of :math:`&lt;g_1&gt;/&lt;g_2&gt;`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Clean the input and set defaults</span>
    <span class="n">g1data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g1i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">g1i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">g2data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">g2data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">g1data_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">g1data_i</span> <span class="ow">in</span> <span class="n">g1data</span><span class="p">]</span>
        
    <span class="n">g1star</span> <span class="o">=</span> <span class="n">_calculate_win_avgs</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">g1data</span><span class="p">)</span>
    <span class="n">g2star</span> <span class="o">=</span> <span class="n">_calculate_win_avgs</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">g2data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g1star</span><span class="p">,</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g2star</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="calculate_pmf"><a class="viewcode-back" href="../modules/emus.html#emus.calculate_pmf">[docs]</a><span class="k">def</span> <span class="nf">calculate_pmf</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">,</span> <span class="n">psis</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span><span class="n">kT</span><span class="o">=</span><span class="n">DEFAULT_KT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the free energy surface along a coordinate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cv_trajs : 2D data structure</span>
<span class="sd">        Data structure containing trajectories in the collective variable space.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    domain : tuple</span>
<span class="sd">        Tuple containing the dimensions of the space over which to construct the pmf, e.g. (-180,180) or ((0,1),(-3.14,3.14)) z (1D array or list): Normalization constants for each window</span>
<span class="sd">    nbins : int or tuple, optional</span>
<span class="sd">        Number of bins to use.  If int, uses that many bins in each dimension.  If tuple, e.g. (100,20), uses 100 bins in the first dimension and 20 in the second.</span>
<span class="sd">    kT : float, optional</span>
<span class="sd">        Value of kT to scale the PMF by.  If not provided, set to 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pmf : nd array</span>
<span class="sd">        Returns the potential of mean force as a d dimensional array, where d is the number of collective variables.</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">domain</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)))</span>
    <span class="n">ndims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">domain</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span> <span class="c"># Make nbins to an iterable in the 1d case.</span>
        <span class="n">nbins</span> <span class="o">=</span> <span class="p">[</span><span class="n">nbins</span><span class="p">]</span><span class="o">*</span><span class="n">ndims</span>
    <span class="n">domainwdth</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c"># Calculate the PMF</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">xtraj_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cv_trajs</span><span class="p">):</span>
<span class="c">#        xtraj_i = (xtraj_i - domain[:,0])%domainwdth + domain[:,0]</span>
        <span class="n">hist_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span> <span class="c"># Histogram of window i</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xtraj_i</span><span class="p">):</span>
            <span class="n">psi_i_n</span> <span class="o">=</span> <span class="n">psis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
            <span class="c"># We find the coordinate of the bin we land in.</span>
            <span class="n">coordbins</span> <span class="o">=</span> <span class="p">(</span><span class="n">coord</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">domainwdth</span><span class="o">*</span><span class="n">nbins</span>
            <span class="n">coordbins</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coordbins</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psi_i_n</span><span class="p">)</span>
            <span class="n">hist_i</span><span class="p">[</span><span class="n">coordbins</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="n">hist</span><span class="o">+=</span><span class="n">hist_i</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">xtraj_i</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">pmf</span> <span class="o">=-</span><span class="n">kT</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
    <span class="n">pmf</span> <span class="o">-=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pmf</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="c"># Calculate the centers of each histogram bin.</span>
    <span class="k">return</span> <span class="n">pmf</span>
</div>
<div class="viewcode-block" id="calculate_zs"><a class="viewcode-back" href="../modules/emus.html#emus.calculate_zs">[docs]</a><span class="k">def</span> <span class="nf">calculate_zs</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">nMBAR</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tol</span><span class="o">=</span><span class="n">DEFAULT_MBAR_TOL</span><span class="p">,</span><span class="n">use_iats</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the normalization constants for the windows.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nMBAR : int, optional (default 0)</span>
<span class="sd">         Maximum number of MBAR iterations to perform.</span>
<span class="sd">    tol : float, optional (see _defaults.py for default)</span>
<span class="sd">        If the relative residual falls beneath the tolerance, the MBAR iteration is truncated.</span>
<span class="sd">    use_iats : bool, optional</span>
<span class="sd">        If true, estimate integrated autocorrelation time in each MBAR iteration.  Likely unnecessary unless dynamics are expected to be drastically different in each window. If iats is provided, the iteration will use those rather than estimating them in each step.</span>
<span class="sd">    iat_method : string, optional</span>
<span class="sd">        Routine to use for calculating integrated autocorrelation times.  Currently accepts DEFAULT_IAT, &#39;acor&#39;, and &#39;icce&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Values for the Normalization constant in each window.</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        Matrix to take the eigenvalue of for MBAR.</span>
<span class="sd">    iats : 1D array</span>
<span class="sd">        Estimated values of the autocorrelation time.  Only returned if use_iats is true.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span> <span class="c"># Number of windows</span>
    <span class="n">Npnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">psis_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">psis_i</span> <span class="ow">in</span> <span class="n">psis</span><span class="p">])</span>
    <span class="n">Npnts</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Npnts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">use_iats</span><span class="p">:</span>
        <span class="n">z</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">iats</span> <span class="o">=</span> <span class="n">emus_iter</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span><span class="n">return_iats</span><span class="o">=</span><span class="n">use_iats</span><span class="p">,</span><span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">z</span><span class="p">,</span><span class="n">F</span> <span class="o">=</span> <span class="n">emus_iter</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span><span class="n">return_iats</span><span class="o">=</span><span class="n">use_iats</span><span class="p">,</span><span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
        <span class="n">iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># we perform the self-consistent polishing iteration</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nMBAR</span><span class="p">):</span>
        <span class="n">z_old</span> <span class="o">=</span> <span class="n">z</span>
        <span class="n">Apart</span> <span class="o">=</span> <span class="n">Npnts</span><span class="o">/</span><span class="n">z_old</span>
        <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="n">Apart</span><span class="p">)</span>
        <span class="n">Amat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="n">iats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_iats</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">iats</span> <span class="o">=</span> <span class="n">emus_iter</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">Amat</span><span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span><span class="n">return_iats</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">iat_method</span><span class="o">=</span><span class="n">iat_method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">z</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">emus_iter</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">Amat</span><span class="p">,</span><span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">)</span>
        <span class="c"># Check if we have converged.	</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">z_old</span><span class="p">)</span><span class="o">/</span><span class="n">z_old</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>
                            
    <span class="k">if</span> <span class="n">use_iats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">iats</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span>

</div>
<div class="viewcode-block" id="emus_iter"><a class="viewcode-back" href="../modules/emus.html#emus.emus_iter">[docs]</a><span class="k">def</span> <span class="nf">emus_iter</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span> <span class="n">Avals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_iats</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span><span class="n">iat_method</span><span class="o">=</span><span class="n">DEFAULT_IAT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs one step of the the EMUS iteration.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    Avals : 2D array-like, optional</span>
<span class="sd">        Weights in front of :math:`\psi` in the overlap matrix.</span>
<span class="sd">    neighbors : 2D array-like, optional</span>
<span class="sd">        List showing which windows neighbor which.  See neighbors_harmonic in usutils. </span>
<span class="sd">    return_iats : bool, optional</span>
<span class="sd">        Whether or not to calculate integrated autocorrelation times of :math:`\psi_ii^*` for each window.</span>
<span class="sd">    iat_method : string, optional</span>
<span class="sd">        Routine to use for calculating said iats.  Accepts &#39;ipce&#39;, &#39;acor&#39;, and &#39;icce&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : 1D array</span>
<span class="sd">        Normalization constants for each window</span>
<span class="sd">    F : 2D array</span>
<span class="sd">        The overlap matrix constructed for the eigenproblem.</span>
<span class="sd">    iats : 1D array</span>
<span class="sd">        If return_iats chosen, returns the iats that have been estimated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c"># Initialize variables</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psis</span><span class="p">)</span> <span class="c"># Number of windows</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">))</span> <span class="c"># Initialize F Matrix</span>
    <span class="c"># Take care of defaults..</span>
    <span class="k">if</span> <span class="n">return_iats</span><span class="p">:</span>
        <span class="n">iats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="n">iatroutine</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">_get_iat_method</span><span class="p">(</span><span class="n">iat_method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Avals</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">Avals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">L</span><span class="p">,</span><span class="n">L</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="n">nbrs_i</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">A_nbs</span> <span class="o">=</span> <span class="n">Avals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">nbrs_i</span><span class="p">]</span>
        <span class="n">nbr_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nbrs_i</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">Fi_out</span> <span class="o">=</span> <span class="n">calculate_Fi</span><span class="p">(</span><span class="n">psis</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nbr_index</span><span class="p">,</span><span class="n">A_nbs</span><span class="p">,</span><span class="n">return_iats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_iats</span><span class="p">:</span>
            <span class="n">Fi</span><span class="p">,</span> <span class="n">trajs</span> <span class="o">=</span> <span class="n">Fi_out</span>
            <span class="n">iats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">iatroutine</span><span class="p">(</span><span class="n">trajs</span><span class="p">[</span><span class="n">nbr_index</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Fi</span> <span class="o">=</span> <span class="n">Fi_out</span>
        <span class="c"># Unpack the Neighbor list</span>
        <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">unpackNbrs</span><span class="p">(</span><span class="n">Fi</span><span class="p">,</span><span class="n">nbrs_i</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">lm</span><span class="o">.</span><span class="n">stationary_distrib</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_iats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">iats</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">F</span>
</div>
<div class="viewcode-block" id="calculate_Fi"><a class="viewcode-back" href="../modules/emus.html#emus.calculate_Fi">[docs]</a><span class="k">def</span> <span class="nf">calculate_Fi</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Avals_i</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_trajs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the values of a single row in the F matrix.  If neighborlists are being used, psi_i, and Avals_i should be the neighborlisted data structure, and the row will be need to be unpacked using the neighborlist.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psi_i : 2D array-like</span>
<span class="sd">        Values of :math:`\psi` collected in window i.  The j&#39;th column corresponds to the j&#39;th neighboring window.</span>
<span class="sd">    i : int</span>
<span class="sd">        Index of the window where the data was collected.</span>
<span class="sd">    Avals_i : 1D array-like</span>
<span class="sd">        Weights in front of :math:`\psi_{ij}` in the overlap matrix.</span>
<span class="sd">    return_trajs : bool, optional</span>
<span class="sd">        Whether or not to return the trajectories that are averaged to calculate the values of F.  These can be useful for estimating autocorrelation times and performing error analysis.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Fi : 1D array </span>
<span class="sd">        The (neighborlisted) row in the F matrix</span>
<span class="sd">    trajs : 2D array, optional</span>
<span class="sd">        If return_trajs is True, returns the trajectories used in calculating the values of F</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Setup</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">psi_i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="c"># Number of neighboring windows</span>
    <span class="n">Fi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="c"># Take care of defaults</span>
    <span class="k">if</span> <span class="n">Avals_i</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">Avals_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
     
    <span class="n">psi_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psi_i</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span><span class="n">Avals_i</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">return_trajs</span><span class="p">:</span>
        <span class="n">trajs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">psi_i</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="n">Ftraj</span> <span class="o">=</span> <span class="n">psi_i</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">denom</span> <span class="c"># traj \psi_j/{\sum_k \psi_k A_k}</span>
        <span class="n">Fi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">Ftraj</span><span class="p">)</span>
        <span class="n">Fi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Avals_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_trajs</span><span class="p">:</span>
            <span class="n">trajs</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ftraj</span>
    <span class="k">if</span> <span class="n">return_trajs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Fi</span><span class="p">,</span> <span class="n">trajs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Fi</span>
    </div>
<span class="k">def</span> <span class="nf">_calculate_win_avgs</span><span class="p">(</span><span class="n">psis</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">gdata</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method estimating the scaled averages in each window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    psis : 3D data structure</span>
<span class="sd">        The values of the bias functions evaluated each window and timepoint.  See `datastructures &lt;../datastructures.html#data-from-sampling&gt;`__ for more information.</span>
<span class="sd">    z : ndarray</span>
<span class="sd">        Array containing the normalization constants</span>
<span class="sd">    gdata : 2D data structure</span>
<span class="sd">        Trajectory of observable in the numerator.  First dimension corresponds to the window index and the second to the point in the trajectory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gstar : 1D array</span>
<span class="sd">        Array where element i is the estimate of :math:`&lt;g^*&gt;` in window i.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gstar</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">psi_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">psis</span><span class="p">):</span>
        <span class="n">denom_i</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psi_i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">gstar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">gdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">denom_i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gstar</span><span class="p">)</span>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Erik H Thiede.
    </p>
  </div>

  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
  
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>